/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2018 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/


struct __unaligned __declspec(align(1)) battleye_stack_report
{
    __int8 unknown;
    __int8 report_id;
    __int8 hook_id;
    __int64 caller;
    __int64 function_dump[4];
    __int64 allocation_base;
    __int64 base_address;
    __int32 region_size;
    __int32 type_protect_state;
};

void __fastcall VHE(FARPROC (__stdcall *GetProcAddress)(HMODULE, LPCSTR), __int64 SendReport, HMODULE (__stdcall *GetModuleHandleA)(LPCSTR), __int64 a4, __int64 last_status); // idb
LONG __fastcall VectoredHandler(_EXCEPTION_POINTERS *exception);
void *unknown_fn();

void __fastcall VHE(FARPROC (__stdcall *GetProcAddress)(HMODULE, LPCSTR), __int64 SendReport, HMODULE (__stdcall *GetModuleHandleA)(LPCSTR), __int64 a4, __int64 last_status)
{
  int index; // [rsp+30h] [rbp-3E8h]
  char byte_copy; // [rsp+34h] [rbp-3E4h]
  int i; // [rsp+38h] [rbp-3E0h]
  char status; // [rsp+3Ch] [rbp-3DCh]
  int l; // [rsp+40h] [rbp-3D8h]
  int j; // [rsp+44h] [rbp-3D4h]
  int n; // [rsp+48h] [rbp-3D0h]
  int jj; // [rsp+4Ch] [rbp-3CCh]
  int ll; // [rsp+50h] [rbp-3C8h]
  int k; // [rsp+54h] [rbp-3C4h]
  int m; // [rsp+58h] [rbp-3C0h]
  int ii; // [rsp+5Ch] [rbp-3BCh]
  int kk; // [rsp+60h] [rbp-3B8h]
  CHAR str_CallWindowProcW[16]; // [rsp+68h] [rbp-3B0h]
  CHAR str_sqrtf[6]; // [rsp+78h] [rbp-3A0h]
  CHAR str_Sleep[6]; // [rsp+80h] [rbp-398h]
  BYTE array_1[7]; // [rsp+88h] [rbp-390h]
  BYTE array_3[7]; // [rsp+90h] [rbp-388h]
  CHAR str_dxgi[9]; // [rsp+98h] [rbp-380h]
  CHAR str_ntdll[10]; // [rsp+A8h] [rbp-370h]
  BYTE array_2[10]; // [rsp+B8h] [rbp-360h]
  CHAR str_d3d11[10]; // [rsp+C8h] [rbp-350h]
  CHAR str_NtSetEvent[11]; // [rsp+D8h] [rbp-340h]
  CHAR str_win32u[11]; // [rsp+E8h] [rbp-330h]
  CHAR str_USER32[11]; // [rsp+F8h] [rbp-320h]
  CHAR str_ucrtbase[13]; // [rsp+108h] [rbp-310h]
  CHAR str_IsBadReadPtr[13]; // [rsp+118h] [rbp-300h]
  CHAR str_GetCursorPos[13]; // [rsp+128h] [rbp-2F0h]
  CHAR str_KERNEL32[13]; // [rsp+138h] [rbp-2E0h]
  CHAR str_UnityPlayer[16]; // [rsp+148h] [rbp-2D0h]
  CHAR str_GetAsyncKeyState[17]; // [rsp+158h] [rbp-2C0h]
  CHAR str_BEClient_x64[17]; // [rsp+170h] [rbp-2A8h]
  CHAR str_NtUserPeekMessage[18]; // [rsp+188h] [rbp-290h]
  CHAR str_GetForegroundWindow[20]; // [rsp+1A0h] [rbp-278h]
  CHAR str_NtQueryVirtualMemory[21]; // [rsp+1B8h] [rbp-260h]
  CHAR str_NtProtectVirtualMemory[23]; // [rsp+1D0h] [rbp-248h]
  CHAR str_NtUserGetAsyncKeyState[23]; // [rsp+1E8h] [rbp-230h]
  BYTE array[25]; // [rsp+200h] [rbp-218h]
  CHAR str_vsprintf_s[26]; // [rsp+220h] [rbp-1F8h]
  CHAR str_AddVectoredExceptionHandler[28]; // [rsp+240h] [rbp-1D8h]
  CHAR str_RemoveVectoredExceptionHandler[31]; // [rsp+260h] [rbp-1B8h]
  int mm; // [rsp+280h] [rbp-198h]
  PVECTORED_EXCEPTION_HANDLER Handler; // [rsp+288h] [rbp-190h]
  HMODULE hNtdll_1; // [rsp+290h] [rbp-188h]
  int unknown; // [rsp+298h] [rbp-180h]
  ULONG NewAccessProtection; // [rsp+29Ch] [rbp-17Ch]
  HMODULE hUSER32l; // [rsp+2A0h] [rbp-178h]
  __int64 d3d11_code_section_start; // [rsp+2A8h] [rbp-170h]
  HMODULE hD3d11; // [rsp+2B0h] [rbp-168h]
  HMODULE hDxgi; // [rsp+2B8h] [rbp-160h]
  HMODULE hUnityPlayer; // [rsp+2C0h] [rbp-158h]
  void (__stdcall *Sleep)(DWORD); // [rsp+2C8h] [rbp-150h]
  HMODULE hkernel32; // [rsp+2D0h] [rbp-148h]
  HMODULE hUcrtbase; // [rsp+2D8h] [rbp-140h]
  __int64 d3d11_nt_headers; // [rsp+2E0h] [rbp-138h]
  char *last_status_1; // [rsp+2E8h] [rbp-130h]
  __int64 ntdll_code_section_start; // [rsp+2F0h] [rbp-128h]
  __int64 dxgi_nt_headers; // [rsp+2F8h] [rbp-120h]
  __int64 dxgi_code_section_start; // [rsp+300h] [rbp-118h]
  ULONG NumberOfBytesToProtect[2]; // [rsp+308h] [rbp-110h]
  HMODULE hBEClient; // [rsp+310h] [rbp-108h]
  __int64 ntdll_nt_headers; // [rsp+318h] [rbp-100h]
  PVOID (__stdcall *AddVectoredExceptionHandler)(ULONG, PVECTORED_EXCEPTION_HANDLER); // [rsp+320h] [rbp-F8h]
  HMODULE hWin32u; // [rsp+328h] [rbp-F0h]
  PVOID Vectored_Handler; // [rsp+330h] [rbp-E8h]
  NTSTATUS (__stdcall *NtProtectVirtualMemory)(HANDLE, PVOID *, PULONG, ULONG, PULONG); // [rsp+338h] [rbp-E0h]
  PVOID BaseAddress; // [rsp+340h] [rbp-D8h]
  ULONG (__stdcall *RemoveVectoredExceptionHandler)(PVOID); // [rsp+348h] [rbp-D0h]
  __int64 NtQueryVirtualMemory_1; // [rsp+350h] [rbp-C8h]
  __int64 functions[22]; // [rsp+360h] [rbp-B8h]
  __int64 SendReport_1; // [rsp+428h] [rbp+10h]
  HMODULE (__stdcall *GetModuleHandleA_1)(LPCSTR); // [rsp+430h] [rbp+18h]
  FARPROC (__stdcall *GetProcAddress_1)(HMODULE, LPCSTR); // [rsp+438h] [rbp+20h]

  LODWORD(GetProcAddress_1) = (_DWORD)GetProcAddress;
  GetModuleHandleA_1 = GetModuleHandleA;
  SendReport_1 = SendReport;
  strcpy(str_KERNEL32, "KERNEL32.dll");
  hkernel32 = GetModuleHandleA(str_KERNEL32);
  status = 1;
  strcpy(str_BEClient_x64, "BEClient_x64.dll");
  hBEClient = GetModuleHandleA_1(str_BEClient_x64);
  if ( *(_DWORD *)((char *)hBEClient + *((int *)hBEClient + 0xF) + 8) < 0x5D7AA2AFu )
    last_status_1 = &status;
  else
    last_status_1 = (char *)last_status;
  strcpy(str_AddVectoredExceptionHandler, "AddVectoredExceptionHandler");
  AddVectoredExceptionHandler = (PVOID (__stdcall *)(ULONG, PVECTORED_EXCEPTION_HANDLER))GetProcAddress_1(
                                                                                           hkernel32,
                                                                                           str_AddVectoredExceptionHandler);
  if ( AddVectoredExceptionHandler )
  {
    Handler = (PVECTORED_EXCEPTION_HANDLER)VectoredHandler;
    *(_QWORD *)((char *)VectoredHandler + 0xE) = SendReport_1;
    strcpy(str_ntdll, "ntdll.dll");
    hNtdll_1 = GetModuleHandleA_1(str_ntdll);
    strcpy(str_NtQueryVirtualMemory, "NtQueryVirtualMemory");
    NtQueryVirtualMemory_1 = (__int64)GetProcAddress_1(hNtdll_1, str_NtQueryVirtualMemory);
    *(_QWORD *)((char *)Handler + 0x1D) = NtQueryVirtualMemory_1;
    *(_QWORD *)((char *)Handler + 0x2F) = GetModuleHandleA_1(0i64);
    Vectored_Handler = AddVectoredExceptionHandler(1u, Handler);
    if ( Vectored_Handler )
    {
      memset(functions, 0, sizeof(functions));
      strcpy(str_USER32, "USER32.dll");
      hUSER32l = GetModuleHandleA_1(str_USER32);
      strcpy(str_GetAsyncKeyState, "GetAsyncKeyState");
      functions[0] = (__int64)GetProcAddress_1(hUSER32l, str_GetAsyncKeyState);
      strcpy(str_GetCursorPos, "GetCursorPos");
      functions[1] = (__int64)GetProcAddress_1(hUSER32l, str_GetCursorPos);
      strcpy(str_IsBadReadPtr, "IsBadReadPtr");
      functions[2] = (__int64)GetProcAddress_1(hkernel32, str_IsBadReadPtr);
      strcpy(str_win32u, "win32u.dll");
      hWin32u = GetModuleHandleA_1(str_win32u);
      strcpy(str_NtUserGetAsyncKeyState, "NtUserGetAsyncKeyState");
      functions[3] = (__int64)GetProcAddress_1(hWin32u, str_NtUserGetAsyncKeyState);
      strcpy(str_GetForegroundWindow, "GetForegroundWindow");
      functions[4] = (__int64)GetProcAddress_1(hUSER32l, str_GetForegroundWindow);
      strcpy(str_CallWindowProcW, "CallWindowProcW");
      functions[5] = (__int64)GetProcAddress_1(hUSER32l, str_CallWindowProcW);
      strcpy(str_NtUserPeekMessage, "NtUserPeekMessage");
      functions[6] = (__int64)GetProcAddress_1(hWin32u, str_NtUserPeekMessage);
      strcpy(str_NtSetEvent, "NtSetEvent");
      functions[7] = (__int64)GetProcAddress_1(hNtdll_1, str_NtSetEvent);
      for ( i = 6; i <= 7; ++i )
      {
        if ( functions[i] )
        {
          for ( j = 0; j < 0x20; ++j )
          {
            _mm_lfence();
            if ( *(_WORD *)(functions[i] + j) == 0x50F )
            {
              _mm_lfence();
              if ( *(unsigned __int8 *)(functions[i] + j + 2) == 0xC3 )
              {
                functions[i] += j;
                break;
              }
            }
          }
        }
      }
      strcpy(str_UnityPlayer, "UnityPlayer.dll");
      hUnityPlayer = GetModuleHandleA_1(str_UnityPlayer);
      *(_QWORD *)((char *)Handler + 0x2F) = hUnityPlayer;
      if ( *(_DWORD *)((char *)hUnityPlayer + 0x55B942) == 0xC35B5D5F
        && *(_DWORD *)((char *)hUnityPlayer + 0x54B6CB) == 0x48038B48 )
      {
        functions[8] = (__int64)hUnityPlayer + 0x55B945;// present_fn retn
      }
      if ( functions[2] && *(_DWORD *)functions[2] == 0x18EC8348 )
        functions[12] = functions[2] + 4;
      array[0] = 0x48;
      array[1] = 0x89u;
      array[2] = 0x45;
      array[3] = 0x58;
      array[4] = 0x48;
      array[5] = 0x8Bu;
      array[6] = 0xCDu;
      array[7] = 0x48;
      array[8] = 0x8Bu;
      array[9] = 0x43;
      array[10] = 0x58;
      array[11] = 0x48;
      array[12] = 0x89u;
      array[13] = 0x45;
      array[14] = 0x60;
      array[15] = 0x48;
      array[16] = 0x8Bu;
      array[17] = 0x53;
      array[18] = 0x58;
      array[19] = 0x48;
      array[20] = 0x8Bu;
      array[21] = 0x43;
      array[22] = 0x50;
      array[23] = 0xFFu;
      array[24] = 0x15;
      ntdll_nt_headers = (__int64)hNtdll_1 + *((int *)hNtdll_1 + 0xF) + 0x18;
      ntdll_code_section_start = (__int64)hNtdll_1 + *(unsigned int *)(ntdll_nt_headers + 0x14);
      for ( k = 0; k + 0x19i64 <= (unsigned __int64)*(unsigned int *)(ntdll_nt_headers + 4); ++k )
      {
        for ( l = 0; (unsigned __int64)l < 0x19 && *(unsigned __int8 *)(ntdll_code_section_start + l + k) == array[l]; ++l )
          ;
        if ( l == 0x19i64 )
        {
          functions[13] = k + ntdll_code_section_start + l - 2;// call    cs:__guard_dispatch_icall_fptr
          break;
        }
      }
      strcpy(str_ucrtbase, "ucrtbase.dll");
      hUcrtbase = GetModuleHandleA_1(str_ucrtbase);
      if ( hUcrtbase )
      {
        strcpy(str_sqrtf, "sqrtf");
        functions[14] = (__int64)GetProcAddress_1(hUcrtbase, str_sqrtf);
        strcpy(str_vsprintf_s, "__stdio_common_vsprintf_s");
        functions[15] = (__int64)GetProcAddress_1(hUcrtbase, str_vsprintf_s);
      }
      strcpy(str_dxgi, "dxgi.dll");
      hDxgi = GetModuleHandleA_1(str_dxgi);
      if ( hDxgi )
      {
        array_1[0] = 0x48;
        array_1[1] = 0x83u;
        array_1[2] = 0xC1u;
        array_1[3] = 0x80u;
        array_1[4] = 0x48;
        array_1[5] = 0xFFu;
        array_1[6] = 0x25;
        dxgi_nt_headers = (__int64)hDxgi + *((int *)hDxgi + 0xF) + 0x18;
        dxgi_code_section_start = (__int64)hDxgi + *(unsigned int *)(dxgi_nt_headers + 0x14);
        for ( m = 0; m + 7i64 <= (unsigned __int64)*(unsigned int *)(dxgi_nt_headers + 4); ++m )
        {
          for ( n = 0; (unsigned __int64)n < 7 && *(unsigned __int8 *)(dxgi_code_section_start + n + m) == array_1[n]; ++n )
            ;
          if ( n == 7i64 )
          {
            functions[16] = m + dxgi_code_section_start;// CDXGIFactory::TakeLock  add rcx, 0FFFFFFFFFFFFFF80h
            break;
          }
        }
      }
      str_CallWindowProcW[14] = 0x41;
      functions[18] = (__int64)GetProcAddress_1(hUSER32l, str_CallWindowProcW);
      strcpy(str_d3d11, "d3d11.dll");
      hD3d11 = GetModuleHandleA_1(str_d3d11);
      if ( hD3d11 )
      {
        array_2[0] = 0;
        array_2[1] = 0;
        array_2[2] = 0x45;
        array_2[3] = 0x33;
        array_2[4] = 0xC9u;
        array_2[5] = 0x44;
        array_2[6] = 0x3B;
        array_2[7] = 0xD0u;
        array_2[8] = 0x77;
        array_2[9] = 8;
        d3d11_nt_headers = (__int64)hD3d11 + *((int *)hD3d11 + 0xF) + 0x18;
        d3d11_code_section_start = (__int64)hD3d11 + *(unsigned int *)(d3d11_nt_headers + 0x14);
        for ( ii = 0; ii + 0xAi64 <= (unsigned __int64)*(unsigned int *)(d3d11_nt_headers + 4); ++ii )
        {
          for ( jj = 0;
                (unsigned __int64)jj < 0xA && *(unsigned __int8 *)(d3d11_code_section_start + jj + ii) == array_2[jj];
                ++jj )
          {
            ;
          }
          if ( jj == 0xAi64 )
          {
            functions[19] = d3d11_code_section_start + ii - 0x13;// CContext::TID3D11DeviceContext_RSGetViewports lea rbx, [rcx-0D8h]
            break;
          }
        }
        array_3[0] = 0x48;
        array_3[1] = 0x83u;
        array_3[2] = 0xC1u;
        array_3[3] = 0x10;
        array_3[4] = 0x48;
        array_3[5] = 0xFFu;
        array_3[6] = 0x25;
        for ( kk = 0; kk + 7i64 <= (unsigned __int64)*(unsigned int *)(d3d11_nt_headers + 4); ++kk )
        {
          for ( ll = 0;
                (unsigned __int64)ll < 7 && *(unsigned __int8 *)(d3d11_code_section_start + ll + kk) == array_3[ll];// NOutermost::CDevice::LOEnter add rcx, 10h
                ++ll )
          {
            ;
          }
          if ( ll == 7i64 )
          {
            functions[20] = kk + d3d11_code_section_start;
            break;
          }
        }
      }
      strcpy(str_Sleep, "Sleep");
      Sleep = (void (__stdcall *)(DWORD))GetProcAddress_1(hkernel32, str_Sleep);
      strcpy(str_NtProtectVirtualMemory, "NtProtectVirtualMemory");
      NtProtectVirtualMemory = (NTSTATUS (__stdcall *)(HANDLE, PVOID *, PULONG, ULONG, PULONG))GetProcAddress_1(
                                                                                                 hNtdll_1,
                                                                                                 str_NtProtectVirtualMemory);
      for ( index = 0; *last_status_1 && (unsigned __int64)index < 0x16; ++index )
      {
        if ( functions[index] )
        {
          *(_QWORD *)NumberOfBytesToProtect = 1i64;
          BaseAddress = (PVOID)functions[index];
          if ( NtProtectVirtualMemory((HANDLE)-1i64, &BaseAddress, NumberOfBytesToProtect, 0x40u, &NewAccessProtection) >= 0 )
          {
            *((_BYTE *)Handler + 0x40) = index;
            byte_copy = *(_BYTE *)functions[index];
            *((_BYTE *)Handler + 0x45) = byte_copy;
            *(_BYTE *)functions[index] = 0xCCu;
            if ( index != 6 && index != 7 && index != 8 )
            {
              for ( mm = 0; *last_status_1; ++mm )
              {
                unknown = index == 19 ? 400 : 200;
                if ( mm >= unknown )
                  break;
                Sleep(5u);
                if ( *(unsigned __int8 *)functions[index] != 0xCC )
                  *(_BYTE *)functions[index] = 0xCCu;
              }
            }
            else
            {
              Sleep(0x3E8u);
            }
            *(_BYTE *)functions[index] = byte_copy;
            Sleep(0x3E8u);
            NtProtectVirtualMemory(
              (HANDLE)-1i64,
              &BaseAddress,
              NumberOfBytesToProtect,
              NewAccessProtection,
              &NewAccessProtection);
          }
        }
      }
      strcpy(str_RemoveVectoredExceptionHandler, "RemoveVectoredExceptionHandler");
      RemoveVectoredExceptionHandler = (ULONG (__stdcall *)(PVOID))GetProcAddress_1(
                                                                     hkernel32,
                                                                     str_RemoveVectoredExceptionHandler);
      RemoveVectoredExceptionHandler(Vectored_Handler);
      Sleep(0x64u);
    }
  }
}

//----- (00000000000018A8) ----------------------------------------------------
LONG __fastcall VectoredHandler(_EXCEPTION_POINTERS *exception)
{
  LONG result; // eax
  __int64 *caller_function; // [rsp+38h] [rbp-1E0h]
  bool call_failed; // [rsp+44h] [rbp-1D4h]
  __int32 region_size; // [rsp+48h] [rbp-1D0h]
  __int32 memory_info; // [rsp+4Ch] [rbp-1CCh]
  _BYTE *unknown_check; // [rsp+60h] [rbp-1B8h]
  PVOID allocation_base; // [rsp+68h] [rbp-1B0h]
  PVOID base_address; // [rsp+70h] [rbp-1A8h]
  _BYTE *unknown_check_1; // [rsp+78h] [rbp-1A0h]
  battleye_stack_report report; // [rsp+80h] [rbp-198h]
  battleye_stack_report report_1; // [rsp+D0h] [rbp-148h]
  battleye_stack_report report_2; // [rsp+120h] [rbp-F8h]
  NTSTATUS (__stdcall *NtQueryVirtualMemory)(HANDLE, PVOID, ULONG, PVOID, SIZE_T, PSIZE_T); // [rsp+170h] [rbp-A8h]
  MEMORY_BASIC_INFORMATION MemoryInformation; // [rsp+178h] [rbp-A0h]
  __int64 v15; // [rsp+200h] [rbp-18h]
  ULONG_PTR ReturnLength; // [rsp+208h] [rbp-10h]
  _EXCEPTION_POINTERS *exception_1; // [rsp+220h] [rbp+8h]

  exception_1 = exception;
  NtQueryVirtualMemory = (NTSTATUS (__stdcall *)(HANDLE, PVOID, ULONG, PVOID, SIZE_T, PSIZE_T))0x7FFC1FD9C4C0i64;
  if ( exception->ExceptionRecord->ExceptionCode == 0x80000003 )
  {
    *(_BYTE *)exception->ContextRecord->Rip = 0x44;

    unknown_check = (char *)unknown_fn() + 3;
    if ( *unknown_check )
    {
      caller_function = *(__int64 **)exception_1->ContextRecord->Rsp;
      call_failed = NtQueryVirtualMemory((HANDLE)-1i64, caller_function, 0, &MemoryInformation, 0x30ui64, &ReturnLength) < 0;
      if ( call_failed
        || MemoryInformation.State != 0x1000
        || MemoryInformation.Type != 0x1000000 && MemoryInformation.RegionSize > 0x2000
        || *(_WORD *)caller_function == 0x23FF
        || *(_WORD *)caller_function == 0x26FF
        || *(_WORD *)caller_function == 0x27FF
        || *(_WORD *)caller_function == 0x65FF
        || *(unsigned __int16 *)caller_function == 0xE3FF )
      {
        *unknown_check = 0xB;
        report.unknown = 0;
        report.report_id = 0x31;
        report.hook_id = 51;
        report.caller = (__int64)caller_function;
        report.function_dump[0] = *caller_function;
        report.function_dump[1] = caller_function[1];
        report.function_dump[2] = caller_function[2];
        report.function_dump[3] = caller_function[3];
        if ( call_failed )
          allocation_base = 0i64;
        else
          allocation_base = MemoryInformation.AllocationBase;
        report.allocation_base = (__int64)allocation_base;
        if ( call_failed )
          base_address = 0i64;
        else
          base_address = MemoryInformation.BaseAddress;
        report.base_address = (__int64)base_address;
        if ( call_failed )
          region_size = 0;
        else
          region_size = MemoryInformation.RegionSize;
        report.region_size = region_size;
        if ( call_failed )
          memory_info = 0;
        else
          memory_info = MemoryInformation.Type | MemoryInformation.Protect | MemoryInformation.State;
        report.type_protect_state = memory_info;
        SendReport(&report, 0x43i64, 0i64);
      }
    }
    result = -1;
  }
  else if ( exception->ExceptionRecord->ExceptionCode == 0x80000004 )
  {
    if ( exception->ContextRecord->Rip >= 0x8000000000000000ui64 )
    {
      report_1.unknown = 0;
      report_1.report_id = 0x31;
      report_1.hook_id = 51;
      report_1.caller = exception->ContextRecord->Rip;
      report_1.function_dump[0] = *(_QWORD *)report_1.caller;
      report_1.function_dump[1] = *(_QWORD *)(report_1.caller + 8);
      report_1.function_dump[2] = *(_QWORD *)(report_1.caller + 16);
      report_1.function_dump[3] = *(_QWORD *)(report_1.caller + 24);
      report_1.allocation_base = 0i64;
      report_1.base_address = 0i64;
      report_1.region_size = 0;
      report_1.type_protect_state = 0;
      SendReport(&report_1, 0x43i64, 0i64);
    }
    result = -1;
  }
  else
  {
    if ( exception->ExceptionRecord->ExceptionCode == 0xC0000005
      && *(_DWORD *)exception->ContextRecord->Rip == 0x70408B48 )
    {
      unknown_check_1 = (char *)unknown_fn() + 3;
      if ( *unknown_check_1 )
      {
        *unknown_check_1 = 0xB;
        report_2.unknown = 0;
        report_2.report_id = 0x31;
        report_2.hook_id = -1;
        report_2.caller = exception_1->ContextRecord->Rip - 3;
        report_2.function_dump[0] = *(_QWORD *)report_2.caller;
        report_2.function_dump[1] = *(_QWORD *)(report_2.caller + 8);
        report_2.function_dump[2] = *(_QWORD *)(report_2.caller + 16);
        report_2.function_dump[3] = *(_QWORD *)(report_2.caller + 24);
        report_2.allocation_base = 0i64;
        report_2.base_address = 0i64;
        report_2.region_size = 0;
        report_2.type_protect_state = 0;
        SendReport(&report_2, 67i64, 0i64);
      }
    }
    result = 0;
  }
  return result;
}


void *unknown_fn()
{
  void *retaddr; // [rsp+0h] [rbp+0h]

  return retaddr;
}
